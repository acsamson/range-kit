# 跨越DOM下文本变化的全面测试场景

## 🎯 测试目标
在DOM结构发生变化（元素添加、删除、移动、属性修改）的情况下，验证选区恢复算法的跨元素恢复能力。

## 📋 测试场景分类

### 1. DOM结构变化（DOM Structure Changes）

#### 1.1 元素新增
- **场景**: 在原有DOM结构中添加新元素
- **例子**:
  ```html
  <!-- 原始结构 -->
  <div><p>段落A</p><p>段落B</p></div>
  选区: "段落A段落B" (跨两个p元素)
  
  <!-- 变化后 -->
  <div><p>段落A</p><span>新增内容</span><p>段落B</p></div>
  期望: 仍能找到跨元素的"段落A段落B"
  ```

#### 1.2 元素删除
- **场景**: 删除某些DOM元素但保留文本内容
- **例子**:
  ```html
  <!-- 原始结构 -->
  <div><h3>标题</h3><p>内容A</p><p>内容B</p></div>
  选区: "内容A内容B" (跨两个p元素)
  
  <!-- 变化后 -->
  <div><h3>标题</h3><div>内容A内容B</div></div>
  期望: 在新的div中找到完整的"内容A内容B"
  ```

#### 1.3 元素标签变更
- **场景**: 保持内容不变，只改变元素标签
- **例子**:
  ```html
  <!-- 原始结构 -->
  <article><h3>标题</h3><p>正文内容</p></article>
  选区: "标题正文内容" (h3→p跨元素)
  
  <!-- 变化后 -->
  <section><h2>标题</h2><div>正文内容</div></section>
  期望: 在h2→div中找到"标题正文内容"
  ```

#### 1.4 嵌套层级变化
- **场景**: DOM嵌套深度发生变化
- **例子**:
  ```html
  <!-- 原始结构 -->
  <div><section><p>段落1</p><p>段落2</p></section></div>
  选区: "段落1段落2"
  
  <!-- 变化后 -->
  <div><article><header><p>段落1</p></header><main><p>段落2</p></main></article></div>
  期望: 在新的嵌套结构中找到跨header→main的"段落1段落2"
  ```

### 2. 元素移动和重排（Element Movement）

#### 2.1 兄弟元素位置交换
- **场景**: 同级元素的顺序发生变化
- **例子**:
  ```html
  <!-- 原始结构 -->
  <div><p id="p1">第一段</p><p id="p2">第二段</p><p id="p3">第三段</p></div>
  选区: "第一段第二段" (p1→p2)
  
  <!-- 变化后 -->
  <div><p id="p2">第二段</p><p id="p3">第三段</p><p id="p1">第一段</p></div>
  期望: 找到重排后的"第一段第二段" (现在p1在最后)
  ```

#### 2.2 元素层级提升
- **场景**: 深层嵌套元素被提升到更浅层级
- **例子**:
  ```html
  <!-- 原始结构 -->
  <div>
    <section>
      <article><p>内容A</p></article>
      <aside><p>内容B</p></aside>
    </section>
  </div>
  选区: "内容A内容B"
  
  <!-- 变化后 -->
  <div>
    <p>内容A</p>
    <p>内容B</p>
  </div>
  期望: 在扁平化结构中找到"内容A内容B"
  ```

#### 2.3 元素跨容器移动
- **场景**: 元素从一个容器移动到另一个容器
- **例子**:
  ```html
  <!-- 原始结构 -->
  <div class="container1">
    <p>移动的段落</p>
    <p>固定段落</p>
  </div>
  <div class="container2"></div>
  选区: "移动的段落固定段落"
  
  <!-- 变化后 -->
  <div class="container1">
    <p>固定段落</p>
  </div>
  <div class="container2">
    <p>移动的段落</p>
  </div>
  期望: 跨容器找到分离的"移动的段落固定段落"
  ```

### 3. 属性和样式变化（Attribute Changes）

#### 3.1 ID属性变化
- **场景**: 元素ID发生变化，但内容保持不变
- **例子**:
  ```html
  <!-- 原始结构 -->
  <div id="content1"><p>段落内容</p></div>
  <div id="content2"><p>其他内容</p></div>
  选区: "段落内容其他内容"
  
  <!-- 变化后 -->
  <div id="newid1"><p>段落内容</p></div>
  <div id="newid2"><p>其他内容</p></div>
  期望: 即使ID变化也能找到相同内容
  ```

#### 3.2 类名变化
- **场景**: 元素class属性变化
- **例子**:
  ```html
  <!-- 原始结构 -->
  <article class="blog-post">
    <h3 class="title">文章标题</h3>
    <p class="content">文章内容</p>
  </article>
  选区: "文章标题文章内容"
  
  <!-- 变化后 -->
  <article class="news-article featured">
    <h3 class="heading primary">文章标题</h3>
    <p class="text body">文章内容</p>
  </article>
  期望: 忽略class变化，找到相同内容
  ```

#### 3.3 自定义属性变化
- **场景**: data-*等自定义属性的变化
- **例子**:
  ```html
  <!-- 原始结构 -->
  <div data-section="intro" data-version="1.0">
    <p>介绍文本</p>
  </div>
  选区: "介绍文本"
  
  <!-- 变化后 -->
  <div data-section="introduction" data-version="2.0" data-updated="true">
    <p>介绍文本</p>
  </div>
  期望: 忽略data属性变化，找到相同文本
  ```

### 4. 内容分割与合并（Content Split & Merge）

#### 4.1 文本节点分割
- **场景**: 原本连续的文本被分割到不同元素
- **例子**:
  ```html
  <!-- 原始结构 -->
  <p>这是一段完整的文本内容</p>
  选区: "一段完整的文本"
  
  <!-- 变化后 -->
  <p>这是<span>一段完整</span>的<em>文本</em>内容</p>
  期望: 跨span和em找到"一段完整的文本"
  ```

#### 4.2 元素内容合并
- **场景**: 多个元素的内容合并到一个元素
- **例子**:
  ```html
  <!-- 原始结构 -->
  <div>
    <span>第一部分</span>
    <span>第二部分</span>
    <span>第三部分</span>
  </div>
  选区: "第一部分第二部分" (跨前两个span)
  
  <!-- 变化后 -->
  <div>
    <p>第一部分第二部分第三部分</p>
  </div>
  期望: 在合并后的p元素中找到"第一部分第二部分"
  ```

#### 4.3 跨块级元素选区
- **场景**: 选区跨越多个块级元素，结构发生重组
- **例子**:
  ```html
  <!-- 原始结构 -->
  <div>
    <h2>章节标题</h2>
    <p>段落一内容</p>
    <p>段落二内容</p>
  </div>
  选区: "章节标题段落一内容段落二"
  
  <!-- 变化后 -->
  <section>
    <header>
      <h1>章节标题</h1>
    </header>
    <article>
      <div>段落一内容段落二内容</div>
    </article>
  </section>
  期望: 跨header→article找到完整选区
  ```

### 5. 动态内容变化（Dynamic Content）

#### 5.1 AJAX内容替换
- **场景**: 通过AJAX动态替换部分内容
- **例子**:
  ```html
  <!-- 原始结构 -->
  <div id="content">
    <p>静态内容开始</p>
    <div id="dynamic">旧的动态内容</div>
    <p>静态内容结束</p>
  </div>
  选区: "静态内容开始旧的动态内容"
  
  <!-- AJAX更新后 -->
  <div id="content">
    <p>静态内容开始</p>
    <section id="dynamic">
      <h3>新标题</h3>
      <p>新的动态内容</p>
    </section>
    <p>静态内容结束</p>
  </div>
  期望: 部分恢复到"静态内容开始"，动态部分失效
  ```

#### 5.2 响应式布局变化
- **场景**: 响应式设计导致的元素重排
- **例子**:
  ```html
  <!-- 桌面版布局 -->
  <div class="desktop-layout">
    <aside class="sidebar">侧边栏内容</aside>
    <main class="content">主要内容</main>
  </div>
  选区: "侧边栏内容主要内容"
  
  <!-- 移动版布局 -->
  <div class="mobile-layout">
    <header>主要内容</header>
    <footer>侧边栏内容</footer>
  </div>
  期望: 在重排后的结构中找到对应内容
  ```

#### 5.3 组件化内容变化
- **场景**: React/Vue组件重新渲染导致的DOM变化
- **例子**:
  ```html
  <!-- 渲染前 -->
  <div data-reactroot="">
    <div class="component-a">
      <p>组件A内容</p>
    </div>
    <div class="component-b">
      <p>组件B内容</p>
    </div>
  </div>
  选区: "组件A内容组件B内容"
  
  <!-- 重新渲染后 -->
  <div data-reactroot="">
    <section class="new-component-wrapper">
      <article>组件A内容</article>
      <aside>组件B内容</aside>
    </section>
  </div>
  期望: 在新的组件结构中找到内容
  ```

### 6. 异常和边界情况（Edge Cases）

#### 6.1 部分元素消失
- **场景**: 选区跨越的某些元素完全消失
- **例子**:
  ```html
  <!-- 原始结构 -->
  <div>
    <p>保留内容</p>
    <p>消失内容</p>
    <p>也保留</p>
  </div>
  选区: "保留内容消失内容也保留"
  
  <!-- 变化后 -->
  <div>
    <p>保留内容</p>
    <p>也保留</p>
  </div>
  期望: 找到剩余的"保留内容也保留"，识别中间部分丢失
  ```

#### 6.2 元素内容完全改变
- **场景**: 元素结构保持但内容完全不同
- **例子**:
  ```html
  <!-- 原始结构 -->
  <article>
    <h2>原始标题</h2>
    <p>原始内容</p>
  </article>
  选区: "原始标题原始内容"
  
  <!-- 变化后 -->
  <article>
    <h2>新的标题</h2>
    <p>全新内容</p>
  </article>
  期望: 算法识别内容完全不匹配，恢复失败
  ```

#### 6.3 DOM树深度剧变
- **场景**: DOM嵌套深度发生极大变化
- **例子**:
  ```html
  <!-- 原始结构 (深度3) -->
  <div><section><p>深层内容</p></section></div>
  
  <!-- 变化后 (深度8) -->
  <div><main><article><section><header><nav><ul><li><p>深层内容</p></li></ul></nav></header></section></article></main></div>
  期望: 通过文本匹配找到最终的p元素
  ```

### 7. 算法层级测试场景（Algorithm Layer Testing）

#### 7.1 L1层失效 → L2层生效
- **场景**: ID锚点失效，但CSS路径仍有效
- **例子**:
  ```html
  <!-- 原始 -->
  <div id="content"><p>文本</p></div>
  
  <!-- 变化后：ID消失但结构保持 -->
  <div class="content"><p>文本</p></div>
  期望: L1失败，L2通过CSS路径成功
  ```

#### 7.2 L1/L2失效 → L3层生效
- **场景**: ID和路径都失效，多重锚点生效
- **例子**:
  ```html
  <!-- 原始 -->
  <section><h3>标题</h3><p>内容</p></section>
  
  <!-- 变化后：结构完全改变但标签类型保持 -->
  <div><article><h3>标题</h3></article><aside><p>内容</p></aside></div>
  期望: L1/L2失败，L3通过h3→p锚点成功
  ```

#### 7.3 仅L4层生效
- **场景**: 前三层都失效，只能通过结构指纹恢复
- **例子**:
  ```html
  <!-- 原始 -->
  <article class="post"><h2>标题</h2><div>内容</div></article>
  
  <!-- 变化后：标签、类名、结构都变化，但保持相似的语义结构 -->
  <section class="blog-entry"><h3>标题</h3><p>内容</p></section>
  期望: 前三层失败，L4通过结构相似度匹配成功
  ```

### 8. 性能压力测试（Performance Stress Testing）

#### 8.1 大量DOM节点
- **场景**: 在包含数千个节点的页面中进行选区恢复
- **例子**: 包含1000+段落的长文档，选区在中间某处

#### 8.2 深度嵌套结构
- **场景**: 极深的DOM嵌套（20+层）中的选区恢复
- **例子**: 复杂的组件嵌套结构

#### 8.3 频繁DOM变化
- **场景**: DOM频繁变化环境下的选区恢复
- **例子**: 实时更新的聊天界面、股票行情等

## 🔧 测试实现策略

### 算法优先级验证
1. 每个场景都应测试L1→L2→L3→L4的降级过程
2. 记录每层算法的命中率和性能
3. 验证降级机制的正确性

### 置信度评估
1. 测试算法对匹配结果的置信度评分
2. 验证低置信度时的处理策略
3. 测试置信度阈值的合理性

### 错误恢复机制
1. 测试部分恢复场景的处理
2. 验证完全失败时的优雅降级
3. 测试错误信息的准确性

## 📊 成功标准

### 恢复准确性
- L1层成功率 > 95% (ID不变场景)
- L2层成功率 > 90% (路径有效场景)
- L3层成功率 > 80% (标签类型保持场景)
- L4层成功率 > 60% (结构相似场景)

### 性能要求
- 单次恢复时间 < 100ms
- 大型页面 (1000+节点) < 500ms
- 内存使用增长 < 50MB

### 置信度准确性
- 高置信度 (>0.8) 准确率 > 95%
- 中置信度 (0.5-0.8) 准确率 > 80%
- 低置信度 (<0.5) 应触发警告或降级
